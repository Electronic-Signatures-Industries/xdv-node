{"version":3,"file":"index.modern.js","sources":["../src/index.ts"],"sourcesContent":["import HttpProvider from 'ethjs-provider-http'\nimport Eth from 'ethjs-query'\nimport EthContract from 'ethjs-contract'\nimport DidRegistryContract from 'ethr-did-resolver/contracts/ethr-did-registry.json'\nimport { createJWT, verifyJWT, SimpleSigner, toEthereumAddress, Signer } from 'did-jwt'\nimport { Buffer } from 'buffer'\nimport { REGISTRY, stringToBytes32, delegateTypes } from 'ethr-did-resolver'\nconst EC = require('elliptic').ec\nconst secp256k1 = new EC('secp256k1')\nconst { Secp256k1VerificationKey2018 } = delegateTypes\n\n\nfunction attributeToHex (key, value) {\n  if (Buffer.isBuffer(value)) {\n    return `0x${value.toString('hex')}`\n  }\n  const match = key.match(/^did\\/(pub|auth|svc)\\/(\\w+)(\\/(\\w+))?(\\/(\\w+))?$/)\n  if (match) {\n    const encoding = match[6]\n    // TODO add support for base58\n    if (encoding === 'base64') {\n      return `0x${Buffer.from(value, 'base64').toString('hex')}`\n    }\n  }\n  if (value.match(/^0x[0-9a-fA-F]*$/)) {\n    return value\n  }\n  return `0x${Buffer.from(value).toString('hex')}`\n}\n\ninterface IConfig {\n  address: string\n  registry?: string\n  signer?: Signer\n  privateKey?: string\n  rpcUrl?: string\n  provider?: any\n  web3?: any\n}\n\nexport default class EthrDID {\n  public did: string\n  private registry: any\n  private address: string\n  private signer: Signer\n  private owner?: string\n\n  constructor (conf: IConfig) {\n    const provider = this.configureProvider(conf)\n    const eth = new Eth(provider)\n    const registryAddress = conf.registry || REGISTRY\n    const DidReg = new EthContract(eth)(DidRegistryContract)\n    this.registry = DidReg.at(registryAddress)\n    this.address = conf.address\n    if (!this.address) throw new Error('No address is set for EthrDid')\n    this.did = `did:ethr:${this.address}`\n    if (conf.signer) {\n      this.signer = conf.signer\n    } else if (conf.privateKey) {\n      this.signer = SimpleSigner(conf.privateKey)\n    }\n  }\n\n  private configureProvider (conf: IConfig) {\n    if (conf.provider) {\n      return conf.provider\n    } else if (conf.web3) {\n      return conf.web3.currentProvider\n    } else {\n      return new HttpProvider(conf.rpcUrl || 'https://mainnet.infura.io/ethr-did')\n    }\n  }\n\n  \n  static createKeyPair () {\n    const kp = secp256k1.genKeyPair()\n    const publicKey = kp.getPublic('hex')\n    const privateKey = kp.getPrivate('hex')\n    const address = toEthereumAddress(publicKey)\n    return { address, privateKey }\n  }\n\n  async lookupOwner (cache = true) {\n    if (cache && this.owner) return this.owner\n    const result = await this.registry.identityOwner(this.address)\n    return result['0']\n  }\n\n  async changeOwner (newOwner) {\n    const owner = await this.lookupOwner()\n    const txHash = await this.registry.changeOwner(this.address, newOwner, {\n      from: owner\n    })\n    this.owner = newOwner\n    return txHash\n  }\n\n  async addDelegate (delegate, {delegateType = Secp256k1VerificationKey2018, expiresIn = 86400}) {\n    const owner = await this.lookupOwner()\n    return this.registry.addDelegate(\n      this.address,\n      delegateType,\n      delegate,\n      expiresIn,\n      { from: owner }\n    )\n  }\n\n  async revokeDelegate (delegate, delegateType = Secp256k1VerificationKey2018) {\n    const owner = await this.lookupOwner()\n    return this.registry.revokeDelegate(this.address, delegateType, delegate, {\n      from: owner\n    })\n  }\n\n  async setAttribute (key, value, expiresIn = 86400, gasLimit) {\n    const owner = await this.lookupOwner()\n    return this.registry.setAttribute(\n      this.address,\n      stringToBytes32(key),\n      attributeToHex(key, value),\n      expiresIn,\n      {\n        from: owner,\n        gas: gasLimit\n      }\n    )\n  }\n\n  async revokeAttribute (key, value, gasLimit) {\n    const owner = await this.lookupOwner()\n    return this.registry.revokeAttribute(\n      this.address,\n      stringToBytes32(key),\n      attributeToHex(key, value),\n      {\n        from: owner,\n        gas: gasLimit\n      }\n    )\n  }\n\n  // Create a temporary signing delegate able to sign JWT on behalf of identity\n  async createSigningDelegate (\n    delegateType = Secp256k1VerificationKey2018,\n    expiresIn = 86400\n  ) {\n    const kp = EthrDID.createKeyPair()\n    this.signer = SimpleSigner(kp.privateKey)\n    const txHash = await this.addDelegate(kp.address, {\n      delegateType,\n      expiresIn\n    })\n    return { kp, txHash }\n  }\n\n  async signJWT (payload, expiresIn?: number) {\n    if (typeof this.signer !== 'function') {\n      throw new Error('No signer configured')\n    }\n    const options = { signer: this.signer, alg: 'ES256K-R', issuer: this.did }\n    if (expiresIn) options['expiresIn'] = expiresIn\n    return createJWT(payload, options)\n  }\n\n  async verifyJWT (jwt, resolver, audience = this.did): Promise<any> {\n    return verifyJWT(jwt, { resolver, audience })\n  }\n}"],"names":["secp256k1","EC","require","ec","Secp256k1VerificationKey2018","delegateTypes","attributeToHex","key","value","Buffer","isBuffer","toString","match","from","EthrDID","constructor","conf","provider","this","configureProvider","eth","Eth","registryAddress","registry","REGISTRY","DidReg","EthContract","DidRegistryContract","at","address","Error","did","signer","privateKey","SimpleSigner","web3","currentProvider","HttpProvider","rpcUrl","[object Object]","kp","genKeyPair","publicKey","getPublic","getPrivate","toEthereumAddress","cache","owner","identityOwner","newOwner","lookupOwner","txHash","changeOwner","delegate","delegateType","expiresIn","addDelegate","revokeDelegate","gasLimit","setAttribute","stringToBytes32","gas","revokeAttribute","createKeyPair","payload","options","alg","issuer","createJWT","jwt","resolver","audience","verifyJWT"],"mappings":"+WAOA,MACMA,EAAY,IAAIC,EADXC,QAAQ,YAAYC,IACN,cACnBC,6BAAEA,GAAiCC,EAGzC,SAASC,EAAgBC,EAAKC,GAC5B,GAAIC,EAAOC,SAASF,GAClB,WAAYA,EAAMG,SAAS,OAE7B,MAAMC,EAAQL,EAAIK,MAAM,oDACxB,OAAIA,GAGe,WAFAA,EAAM,QAGTH,EAAOI,KAAKL,EAAO,UAAUG,SAAS,OAGlDH,EAAMI,MAAM,oBACPJ,OAEGC,EAAOI,KAAKL,GAAOG,SAAS,aAarBG,EAOnBC,YAAaC,GACX,MAAMC,EAAWC,KAAKC,kBAAkBH,GAClCI,EAAM,IAAIC,EAAIJ,GACdK,EAAkBN,EAAKO,UAAYC,EACnCC,EAAS,IAAIC,EAAYN,EAAhB,CAAqBO,GAGpC,GAFAT,KAAKK,SAAWE,EAAOG,GAAGN,GAC1BJ,KAAKW,QAAUb,EAAKa,SACfX,KAAKW,QAAS,UAAUC,MAAM,iCACnCZ,KAAKa,gBAAkBb,KAAKW,QACxBb,EAAKgB,OACPd,KAAKc,OAAShB,EAAKgB,OACVhB,EAAKiB,aACdf,KAAKc,OAASE,EAAalB,EAAKiB,aAI5Bd,kBAAmBH,GACzB,OAAIA,EAAKC,SACAD,EAAKC,SACHD,EAAKmB,KACPnB,EAAKmB,KAAKC,oBAENC,EAAarB,EAAKsB,QAAU,sCAK3CC,uBACE,MAAMC,EAAKxC,EAAUyC,aACfC,EAAYF,EAAGG,UAAU,OACzBV,EAAaO,EAAGI,WAAW,OAEjC,MAAO,CAAEf,QADOgB,EAAkBH,GAChBT,WAAAA,GAGpBM,kBAAmBO,GAAQ,GACzB,OAAIA,GAAS5B,KAAK6B,WAAmBA,kBACXxB,SAASyB,cAAc9B,KAAKW,UACxC,GAGhBU,kBAAmBU,GACjB,MAAMF,aAAmBG,cACnBC,aAAoB5B,SAAS6B,YAAYlC,KAAKW,QAASoB,EAAU,CACrEpC,KAAMkC,IAGR,OADA7B,KAAK6B,MAAQE,EACNE,EAGTZ,kBAAmBc,GAAUC,aAACA,EAAelD,EAAhBmD,UAA8CA,EAAY,QACrF,MAAMR,aAAmBG,cACzB,YAAY3B,SAASiC,YACnBtC,KAAKW,QACLyB,EACAD,EACAE,EACA,CAAE1C,KAAMkC,IAIZR,qBAAsBc,EAAUC,EAAelD,GAC7C,MAAM2C,aAAmBG,cACzB,YAAY3B,SAASkC,eAAevC,KAAKW,QAASyB,EAAcD,EAAU,CACxExC,KAAMkC,IAIVR,mBAAoBhC,EAAKC,EAAO+C,EAAY,MAAOG,GACjD,MAAMX,aAAmBG,cACzB,YAAY3B,SAASoC,aACnBzC,KAAKW,QACL+B,EAAgBrD,GAChBD,EAAeC,EAAKC,GACpB+C,EACA,CACE1C,KAAMkC,EACNc,IAAKH,IAKXnB,sBAAuBhC,EAAKC,EAAOkD,GACjC,MAAMX,aAAmBG,cACzB,YAAY3B,SAASuC,gBACnB5C,KAAKW,QACL+B,EAAgBrD,GAChBD,EAAeC,EAAKC,GACpB,CACEK,KAAMkC,EACNc,IAAKH,IAMXnB,4BACEe,EAAelD,EACfmD,EAAY,OAEZ,MAAMf,EAAK1B,EAAQiD,gBAMnB,OALA7C,KAAKc,OAASE,EAAaM,EAAGP,YAKvB,CAAEO,GAAAA,EAAIW,kBAJaK,YAAYhB,EAAGX,QAAS,CAChDyB,aAAAA,EACAC,UAAAA,KAKJhB,cAAeyB,EAAST,GACtB,GAA2B,wBAAXvB,OACd,UAAUF,MAAM,wBAElB,MAAMmC,EAAU,CAAEjC,OAAQd,KAAKc,OAAQkC,IAAK,WAAYC,OAAQjD,KAAKa,KAErE,OADIwB,IAAWU,EAAO,UAAgBV,GAC/Ba,EAAUJ,EAASC,GAG5B1B,gBAAiB8B,EAAKC,EAAUC,EAAWrD,KAAKa,KAC9C,OAAOyC,EAAUH,EAAK,CAAEC,SAAAA,EAAUC,SAAAA"}