"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.concatKDF = exports.toEthereumAddress = exports.keccak = exports.sha256 = void 0;
const tslib_1 = require("tslib");
const sha256_1 = require("@stablelib/sha256");
const u8a = tslib_1.__importStar(require("uint8arrays"));
const js_sha3_1 = require("js-sha3"); // eslint-disable-line
function sha256(payload) {
    const data = typeof payload === 'string' ? u8a.fromString(payload) : payload;
    return sha256_1.hash(data);
}
exports.sha256 = sha256;
function keccak(data) {
    return new Uint8Array(js_sha3_1.keccak_256.arrayBuffer(data));
}
exports.keccak = keccak;
function toEthereumAddress(hexPublicKey) {
    const hashInput = u8a.fromString(hexPublicKey.slice(2), 'base16');
    return `0x${u8a.toString(keccak(hashInput).slice(-20), 'base16')}`;
}
exports.toEthereumAddress = toEthereumAddress;
function writeUint32BE(value, array = new Uint8Array(4)) {
    const encoded = u8a.fromString(value.toString(), 'base10');
    array.set(encoded, 4 - encoded.length);
    return array;
}
const lengthAndInput = (input) => u8a.concat([writeUint32BE(input.length), input]);
// This implementation of concatKDF was inspired by these two implementations:
// https://github.com/digitalbazaar/minimal-cipher/blob/master/algorithms/ecdhkdf.js
// https://github.com/panva/jose/blob/master/lib/jwa/ecdh/derive.js
function concatKDF(secret, keyLen, alg) {
    if (keyLen !== 256)
        throw new Error(`Unsupported key length: ${keyLen}`);
    const value = u8a.concat([
        lengthAndInput(u8a.fromString(alg)),
        lengthAndInput(new Uint8Array(0)),
        lengthAndInput(new Uint8Array(0)),
        writeUint32BE(keyLen)
    ]);
    // since our key lenght is 256 we only have to do one round
    const roundNumber = 1;
    return sha256_1.hash(u8a.concat([writeUint32BE(roundNumber), secret, value]));
}
exports.concatKDF = concatKDF;
//# sourceMappingURL=Digest.js.map