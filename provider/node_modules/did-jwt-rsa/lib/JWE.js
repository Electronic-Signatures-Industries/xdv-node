"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decryptJWE = exports.createJWE = void 0;
const tslib_1 = require("tslib");
const util_1 = require("./util");
function validateJWE(jwe) {
    if (!(jwe.protected && jwe.iv && jwe.ciphertext && jwe.tag)) {
        throw new Error('Invalid JWE');
    }
    if (jwe.recipients) {
        jwe.recipients.map((rec) => {
            if (!(rec.header && rec.encrypted_key)) {
                throw new Error('Invalid JWE');
            }
        });
    }
}
function encodeJWE({ ciphertext, tag, iv, protectedHeader, recipient }, aad) {
    const jwe = {
        protected: protectedHeader,
        iv: util_1.bytesToBase64url(iv),
        ciphertext: util_1.bytesToBase64url(ciphertext),
        tag: util_1.bytesToBase64url(tag)
    };
    if (aad)
        jwe.aad = util_1.bytesToBase64url(aad);
    if (recipient)
        jwe.recipients = [recipient];
    return jwe;
}
function createJWE(cleartext, encrypters, protectedHeader = {}, aad) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (encrypters[0].alg === 'dir') {
            if (encrypters.length > 1)
                throw new Error('Can only do "dir" encryption to one key.');
            const encryptionResult = yield encrypters[0].encrypt(cleartext, protectedHeader, aad);
            return encodeJWE(encryptionResult, aad);
        }
        else {
            const tmpEnc = encrypters[0].enc;
            if (!encrypters.reduce((acc, encrypter) => acc && encrypter.enc === tmpEnc, true)) {
                throw new Error('Incompatible encrypters passed');
            }
            let cek;
            let jwe;
            for (const encrypter of encrypters) {
                if (!cek) {
                    const encryptionResult = yield encrypter.encrypt(cleartext, protectedHeader, aad);
                    cek = encryptionResult.cek;
                    jwe = encodeJWE(encryptionResult, aad);
                }
                else {
                    jwe.recipients.push(yield encrypter.encryptCek(cek));
                }
            }
            return jwe;
        }
    });
}
exports.createJWE = createJWE;
function decryptJWE(jwe, decrypter) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        validateJWE(jwe);
        const protHeader = JSON.parse(util_1.decodeBase64url(jwe.protected));
        if (protHeader.enc !== decrypter.enc)
            throw new Error(`Decrypter does not support: '${protHeader.enc}'`);
        const sealed = util_1.toSealed(jwe.ciphertext, jwe.tag);
        const aad = new Uint8Array(Buffer.from(jwe.aad ? `${jwe.protected}.${jwe.aad}` : jwe.protected));
        let cleartext = null;
        if (protHeader.alg === 'dir' && decrypter.alg === 'dir') {
            cleartext = yield decrypter.decrypt(sealed, util_1.base64ToBytes(jwe.iv), aad);
        }
        else if (!jwe.recipients || jwe.recipients.length === 0) {
            throw new Error('Invalid JWE');
        }
        else {
            for (let i = 0; !cleartext && i < jwe.recipients.length; i++) {
                const recipient = jwe.recipients[i];
                Object.assign(recipient.header, protHeader);
                if (recipient.header.alg === decrypter.alg) {
                    cleartext = yield decrypter.decrypt(sealed, util_1.base64ToBytes(jwe.iv), aad, recipient);
                }
            }
        }
        if (cleartext === null)
            throw new Error('Failed to decrypt');
        return cleartext;
    });
}
exports.decryptJWE = decryptJWE;
//# sourceMappingURL=JWE.js.map