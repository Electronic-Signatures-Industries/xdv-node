"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DID = void 0;
const tslib_1 = require("tslib");
const did_resolver_1 = require("did-resolver");
const dag_jose_utils_1 = require("dag-jose-utils");
const rpc_utils_1 = require("rpc-utils");
const utils_1 = require("./utils");
const JWT_1 = require("./JWT");
tslib_1.__exportStar(require("./types"), exports);
function isResolver(resolver) {
    return 'registry' in resolver && 'cache' in resolver;
}
/**
 * Interact with DIDs.
 */
class DID {
    constructor({ provider, resolver = {}, resolverOptions } = {}) {
        if (provider != null) {
            this._client = new rpc_utils_1.RPCClient(provider);
        }
        this.setResolver(resolver, resolverOptions);
    }
    /**
     * Check if user is authenticated.
     */
    get authenticated() {
        return this._id != null;
    }
    /**
     * Get the DID identifier of the user.
     */
    get id() {
        if (this._id == null) {
            throw new Error('DID is not authenticated');
        }
        return this._id;
    }
    /**
     * Set the DID provider of this instance.
     * Only callable if provider not already set.
     *
     * @param provider    The DIDProvider to use
     */
    setProvider(provider) {
        if (this._client == null) {
            this._client = new rpc_utils_1.RPCClient(provider);
        }
        else if (this._client.connection !== provider) {
            throw new Error('A different provider is already set, create a new DID instance to use another provider');
        }
    }
    /**
     * Set the DID-resolver user by this instance
     *
     * @param resolver            Either a Resolver instance or an object with specific resolvers
     * @param resolverOptions     Options to use for the created resolver. Will be ignored if a Resolver instance is passed
     */
    setResolver(resolver, resolverOptions) {
        this._resolver = isResolver(resolver) ? resolver : new did_resolver_1.Resolver(resolver, resolverOptions);
    }
    /**
     * Authenticate the user.
     */
    authenticate({ provider, paths = [], aud } = {}) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (provider != null) {
                this.setProvider(provider);
            }
            if (this._client == null) {
                throw new Error('No provider available');
            }
            const nonce = utils_1.randomString();
            const jws = yield this._client.request('did_authenticate', {
                nonce,
                aud,
                paths,
            });
            const { kid } = yield this.verifyJWS(jws);
            const payload = utils_1.base64urlToJSON(jws.payload);
            if (!kid.includes(payload.did))
                throw new Error('Invalid authencation response, kid mismatch');
            if (payload.nonce !== nonce)
                throw new Error('Invalid authencation response, wrong nonce');
            if (payload.aud !== aud)
                throw new Error('Invalid authencation response, wrong aud');
            if (payload.exp < Date.now() / 1000)
                throw new Error('Invalid authencation response, expired');
            this._id = payload.did;
            return this._id;
        });
    }
    /**
     * Create a JWS encoded signature over the given payload.
     * Will be signed by the currently authenticated DID.
     *
     * @param payload             The payload to sign
     * @param options             Optional parameters
     */
    createJWS(payload, options = {}) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this._client == null)
                throw new Error('No provider available');
            if (this._id == null)
                throw new Error('DID is not authenticated');
            const { jws } = yield this._client.request('did_createJWS', Object.assign(Object.assign({ did: this._id }, options), { payload }));
            return jws;
        });
    }
    /**
     * Create an IPFS compatibe DagJWS encoded signature over the given payload.
     * Will be signed by the currently authenticated DID.
     *
     * @param payload             The payload to sign, may include ipld links
     * @param options             Optional parameters
     */
    createDagJWS(payload, options = {}) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { cid, linkedBlock } = yield dag_jose_utils_1.encodePayload(payload);
            const payloadCid = utils_1.encodeBase64Url(cid.bytes);
            Object.assign(options, { linkedBlock: utils_1.encodeBase64(linkedBlock) });
            const jws = yield this.createJWS(payloadCid, options);
            jws.link = cid;
            return { jws, linkedBlock };
        });
    }
    /**
     * Verify a JWS. Uses the 'kid' in the header as the way to resolve
     * the author public key.
     *
     * @param jws                 The JWS to verify
     * @returns                   Information about the signed JWS
     */
    verifyJWS(jws) {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (typeof jws !== 'string')
                jws = utils_1.fromDagJWS(jws);
            const kid = utils_1.base64urlToJSON(jws.split('.')[0]).kid;
            if (!kid)
                throw new Error('No "kid" found in jws');
            const didResolutionResult = yield this.resolve(kid);
            const publicKeys = ((_a = didResolutionResult.didDocument) === null || _a === void 0 ? void 0 : _a.verificationMethod) || [];
            // verifyJWS will throw an error if the signature is invalid
            JWT_1.verifyJWS(jws, publicKeys);
            let payload;
            try {
                payload = utils_1.base64urlToJSON(jws.split('.')[1]);
            }
            catch (e) {
                // If an error is thrown it means that the payload is a CID.
            }
            return { kid, payload, didResolutionResult };
        });
    }
    /**
     * Create a JWE encrypted to the given recipients.
     *
     * @param cleartext           The cleartext to be encrypted
     * @param recipients          An array of DIDs
     * @param options             Optional parameters
     */
    createJWE(cleartext, recipients, options = {}) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            throw new Error("Not implemented");
        });
    }
    /**
     * Create an IPFS compatibe DagJWE encrypted to the given recipients.
     *
     * @param cleartext           The cleartext to be encrypted, may include ipld links
     * @param recipients          An array of DIDs
     * @param options             Optional parameters
     */
    createDagJWE(cleartext, recipients, options = {}) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.createJWE(dag_jose_utils_1.prepareCleartext(cleartext), recipients, options);
        });
    }
    /**
     * Try to decrypt the given JWE with the currently authenticated user.
     *
     * @param jwe                 The JWE to decrypt
     * @param options             Optional parameters
     */
    decryptJWE(jwe, options = {}) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this._client == null)
                throw new Error('No provider available');
            if (this._id == null)
                throw new Error('DID is not authenticated');
            const { cleartext } = yield this._client.request('did_decryptJWE', Object.assign(Object.assign({ did: this._id }, options), { jwe }));
            return utils_1.decodeBase64(cleartext);
        });
    }
    /**
     * Try to decrypt the given DagJWE with the currently authenticated user.
     *
     * @param jwe                 The JWE to decrypt
     * @param options             Optional parameters
     * @returns                   An ipld object
     */
    decryptDagJWE(jwe) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const bytes = yield this.decryptJWE(jwe);
            return dag_jose_utils_1.decodeCleartext(bytes);
        });
    }
    /**
     * Resolve the DID Document of the given DID.
     *
     * @param didUrl              The DID to resolve
     */
    resolve(didUrl) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const result = yield this._resolver.resolve(didUrl);
            if (result.didResolutionMetadata.error) {
                const { error, message } = result.didResolutionMetadata;
                const maybeMessage = message ? `, ${message}` : '';
                throw new Error(`Failed to resolve ${didUrl}: ${error}${maybeMessage}`);
            }
            return result;
        });
    }
}
exports.DID = DID;
function resolveX25519Encrypters(recipients, _resolver) {
    throw new Error('Function not implemented.');
}
//# sourceMappingURL=dids.js.map